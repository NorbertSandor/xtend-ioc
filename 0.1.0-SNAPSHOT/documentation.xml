<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="5"?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>xtend-ioc</title>
<date>2015-11-08</date>
</info>
<section xml:id="_introduction">
<title>Introduction</title>
<simpara><emphasis>xtend-ioc</emphasis> is a compile-time inversion of control framework for <link xlink:href="http://www.eclipse.org/xtend/">Xtend</link>.<?asciidoc-br?>
Its main features are</simpara>
<itemizedlist>
<listitem>
<simpara>component instantiation and lifecycle management,</simpara>
</listitem>
<listitem>
<simpara>dependency injection and</simpara>
</listitem>
<listitem>
<simpara>event dispatching between component instances.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_xtend">
<title>Xtend</title>
<simpara><emphasis>xtend-ioc</emphasis> is built on <link xlink:href="http://www.eclipse.org/xtend/">Xtend</link>:</simpara>
<blockquote>
<attribution>
by the Xtend website
</attribution>
<simpara>Xtend is a statically-typed programming language which translates to comprehensible Java source code. Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects.</simpara>
</blockquote>
<simpara>Xtend has lots of useful features compared to Java, and it has fairly good IDE support.
Its advanced <link xlink:href="http://www.eclipse.org/xtend/documentation/204_activeannotations.html">compile-time metaprogramming facilities</link> make it the perfect basis of <emphasis>xtend-ioc</emphasis>.<?asciidoc-br?>
<emphasis>xtend-ioc</emphasis> does not support Java directly, only indirectly via Xtend.</simpara>
<note>
<simpara>Although this documentation sometimes refers to "Java classes", in most cases this means "Java classes translated from Xtend".<?asciidoc-br?>
Similarly, "Java objects" mean instances of "Java classes translated from Xtend".</simpara>
</note>
</section>
<section xml:id="_inversion_of_control_and_dependency_injection">
<title>Inversion of control and dependency injection</title>
<blockquote>
<attribution>
<link xlink:href="https://en.wikipedia.org/wiki/Inversion_of_control">by Wikipedia</link>
</attribution>
<simpara>In software engineering, inversion of control (IoC) describes a design in which custom-written portions of a computer program receive the flow of control from a generic, reusable library. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but with inversion of control, it is the reusable code that calls into the custom, or task-specific, code.</simpara>
</blockquote>
<simpara>In this definition <emphasis>xtend-ioc</emphasis> is the "generic, reusable library" that</simpara>
<variablelist>
<varlistentry>
<term>creates and manages instances of classes</term>
<listitem>
<simpara>instead of the classes would be instantiated using the <literal>new</literal> operator in user code,</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>injects dependencies into objects</term>
<listitem>
<simpara>instead of each object would look up them manually, and</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dispatches events between objects</term>
<listitem>
<simpara>instead of calling methods directly on other objects.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_compile_time_vs_runtime_ioc_frameworks">
<title>Compile-time vs runtime IOC frameworks</title>
<simpara><emphasis>xtend-ioc</emphasis> is a purely compile-time IOC framework.<?asciidoc-br?>
It means that all validation and code generation is performed during the Xtend to Java source code translation phase.<?asciidoc-br?>
This design decision has major advantages like</simpara>
<itemizedlist>
<listitem>
<simpara>most errors are detected in compile-time</simpara>
</listitem>
<listitem>
<simpara>the generated Java code is completely static so e.g. <link xlink:href="http://gwtproject.org/">GWT</link> is supported</simpara>
</listitem>
</itemizedlist>
<simpara>Although there are disadvantages as well compared to runtime IOC frameworks, for example component lookup using runtime classpath scanning cannot be supported.<?asciidoc-br?>
Note that a simple compile-time <link linkend="component-scan">component scanning</link> is supported.</simpara>
</section>
</section>
<section xml:id="_status">
<title>Status</title>
<simpara>The <emphasis>xtend-ioc</emphasis> project is not released to the public yet.<?asciidoc-br?>
Although all features and examples presented in this documentation are working (they are indeed unit tests), the framework source code needs some cleanup&#8230;&#8203;</simpara>
</section>
<section xml:id="_building_blocks">
<title>Building blocks</title>
<simpara>The main building blocks of <emphasis>xtend-ioc</emphasis> are:</simpara>
<itemizedlist>
<listitem>
<simpara>A <emphasis>component</emphasis> is a definition that specifies how instances of it should be created and managed by <emphasis>module</emphasis>s.</simpara>
</listitem>
<listitem>
<simpara>A <emphasis>component instance</emphasis> is a Java object, instance of a <emphasis>component</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>A <emphasis>module</emphasis> is a definition that specifies the <emphasis>component</emphasis>s contained by it.</simpara>
</listitem>
<listitem>
<simpara>A <emphasis>module instance</emphasis> manages the life-cycle of its contained <emphasis>component instance</emphasis>s, provides additional services for them, and may optionally provide external access to them.</simpara>
</listitem>
</itemizedlist>
<simpara>Let&#8217;s see an example just to taste the syntax:</simpara>
<programlisting xml:id="showcase-example-first" language="xtend" linenumbering="unnumbered">interface HelloService { <co xml:id="CO1-1"/>
	def String sayHello(String name)
}

@Component <co xml:id="CO1-2"/>
class EnglishHelloServiceImpl implements HelloService {
	override sayHello(String name) '''Hello «name»!'''
}

@Component
class HungarianHelloServiceImpl implements HelloService {
	override sayHello(String name) '''Szia «name»!'''
}

@Component
class AnotherComponent {
	@Inject
	public EnglishHelloServiceImpl englishHelloService <co xml:id="CO1-3"/>
}

@Module( <co xml:id="CO1-4"/>
components=#[EnglishHelloServiceImpl, HungarianHelloServiceImpl, AnotherComponent] <co xml:id="CO1-5"/>
)
interface ChattyModule {
	def EnglishHelloServiceImpl englishHelloService() <co xml:id="CO1-6"/>

	def HungarianHelloServiceImpl hungarianHelloService() <co xml:id="CO1-7"/>

	def List&lt;? extends HelloService&gt; helloServices() <co xml:id="CO1-8"/>

	def AnotherComponent anotherComponent()
}

class ChattyModuleTest {
	@Test
	def void test() {
		val module = ChattyModule.Peer.initialize <co xml:id="CO1-9"/>
		assertEquals("Hello Jeff!", module.englishHelloService.sayHello("Jeff")) <co xml:id="CO1-10"/>
		assertEquals("Szia Jeff!", module.hungarianHelloService.sayHello("Jeff")) <co xml:id="CO1-11"/>
		assertEquals(2, module.helloServices.size) <co xml:id="CO1-12"/>
		assertTrue(
			module.englishHelloService ===
			module.anotherComponent.englishHelloService <co xml:id="CO1-13"/>
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Define a service interface to "say hello".</para>
</callout>
<callout arearefs="CO1-2">
<para>Annotate classes with <literal>@Component</literal> to turn them to components.</para>
</callout>
<callout arearefs="CO1-3">
<para>Another component with <literal>@Inject</literal>-ed depedency</para>
</callout>
<callout arearefs="CO1-4">
<para>Annotate an interface with <literal>@Module</literal> to turn it to a module.</para>
</callout>
<callout arearefs="CO1-5">
<para>Specify the components contained in the module.</para>
</callout>
<callout arearefs="CO1-6">
<para>Declare a method for accessing the <literal>EnglishHelloServiceImpl</literal> component.</para>
</callout>
<callout arearefs="CO1-7">
<para>Declare a method for accessing the <literal>HungarianHelloServiceImpl</literal> component.</para>
</callout>
<callout arearefs="CO1-8">
<para>Declare a method for accessing all components implementing <literal>HelloService</literal></para>
</callout>
<callout arearefs="CO1-9">
<para>Initialize the module, ie. instantiate it.</para>
</callout>
<callout arearefs="CO1-10">
<para>Say hello in English.</para>
</callout>
<callout arearefs="CO1-11">
<para>Say hello in Hungarian.</para>
</callout>
<callout arearefs="CO1-12">
<para>Count the components implementing <literal>HelloService</literal> - not surprisingly the result is 2.</para>
</callout>
<callout arearefs="CO1-13">
<para>By default components are "singletons" which means that all references point to the same component instance.</para>
</callout>
</calloutlist>
<section xml:id="_components">
<title>Components</title>
<simpara>There are two ways to define a <emphasis>component</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="component-class">component classes</link> and</simpara>
</listitem>
<listitem>
<simpara><link linkend="component-providers">component providers</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="component-class">
<title>@Component / component classes</title>
<simpara xml:id="component-class-requirements">A Java class is a <emphasis>component class</emphasis> if</simpara>
<itemizedlist>
<listitem>
<simpara>it is annotated with <literal>@Component</literal> and</simpara>
</listitem>
<listitem>
<simpara>it has a valid component constructor, that is</simpara>
<itemizedlist>
<listitem>
<simpara>either the class has exactly one constructor annotated with <literal>@Inject</literal></simpara>
</listitem>
<listitem>
<simpara>or none of its constructors is annotated with <literal>@Inject</literal> and a no-args constructor exits (even the default constructor or an explicitly defined one).</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>When a new instance of a <emphasis>component class</emphasis> is requested then it is instantiated by using its <emphasis>component constructor</emphasis>.</simpara>
<simpara><emphasis>Component class</emphasis>es may have superclasses. If a <emphasis>component</emphasis>'s superclass is itself a <emphasis>component class</emphasis> then dependency injection is performed as expected.</simpara>
<tip>
<simpara>Components should be focused in functionality.</simpara>
</tip>
</section>
<section xml:id="component-qualifiers">
<title>@Qualifier / qualifiers</title>
<simpara>Programming against interfaces is considered a good practice therefore components should be referenced by interfaces instead of concrete classes.
When multiple <emphasis>component classes</emphasis> implement the same interface, the component classes can be identified by labeling them with <emphasis>qualifiers</emphasis>.</simpara>
<simpara>A <emphasis>qualifier</emphasis> is an annotation marked with <literal>@Qualifier</literal>:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Qualifier
annotation English {}</programlisting>
<simpara>Let&#8217;s rewrite our <link linkend="showcase-example-first">first example</link> using qualifiers and interface references:</simpara>
<programlisting xml:id="showcase-example-with-qualifiers" language="xtend" linenumbering="unnumbered">interface HelloService {
	def String sayHello(String name)
}

@Qualifier
annotation English { <co xml:id="CO2-1"/>
}

@Qualifier
annotation Hungarian { <co xml:id="CO2-2"/>
}

@Component
@English <co xml:id="CO2-3"/>
class EnglishHelloServiceImpl implements HelloService {
	override sayHello(String name) '''Hello «name»!'''
}

@Component
@Hungarian <co xml:id="CO2-4"/>
class HungarianHelloServiceImpl implements HelloService {
	override sayHello(String name) '''Szia «name»!'''
}

@Component
class AnotherComponent {
	@Inject
	@English
	public HelloService englishHelloService <co xml:id="CO2-5"/>
}

@Module(
	components=#[EnglishHelloServiceImpl, HungarianHelloServiceImpl, AnotherComponent]
)
interface ChattyModule {
	@English <co xml:id="CO2-6"/>
	def HelloService englishHelloService()

	@Hungarian <co xml:id="CO2-7"/>
	def HelloService hungarianHelloService()

	def List&lt;? extends HelloService&gt; helloServices()

	def AnotherComponent anotherComponent()
}

class ChattyModuleTest {
	@Test
	def void test() {
		val module = ChattyModule.Peer.initialize
		assertEquals("Hello Jeff!", module.englishHelloService.sayHello("Jeff"))
		assertEquals("Szia Jeff!", module.hungarianHelloService.sayHello("Jeff"))
		assertEquals(2, module.helloServices.size)
		assertTrue(
			module.englishHelloService ===
			module.anotherComponent.englishHelloService
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Define qualifier <literal>@English</literal>.</para>
</callout>
<callout arearefs="CO2-2">
<para>Define qualifier <literal>@Hungarian</literal>.</para>
</callout>
<callout arearefs="CO2-3">
<para>Qualify <literal>EnglishHelloServiceImpl</literal> with <literal>@English</literal>.</para>
</callout>
<callout arearefs="CO2-4">
<para>Qualify <literal>HungarianHelloServiceImpl</literal> with <literal>@Hungarian</literal>.</para>
</callout>
<callout arearefs="CO2-5">
<para><literal>AnotherComponent</literal> depends on a component implementing <literal>HelloService</literal> and qualified with <literal>@English</literal> (that will be resolved as <literal>EnglishHelloServiceImpl</literal>).</para>
</callout>
<callout arearefs="CO2-6">
<para>Declare a method for accessing the component implementing <literal>HelloService</literal> and qualified with <literal>@English</literal> (that will be resolved as <literal>EnglishHelloServiceImpl</literal>).</para>
</callout>
<callout arearefs="CO2-7">
<para>Declare a method for accessing the component implementing <literal>HelloService</literal> and qualified with <literal>@Hungarian</literal> (that will be resolved as <literal>HungarianHelloServiceImpl</literal>).</para>
</callout>
</calloutlist>
<simpara>Of course a component may have multiple qualifiers like:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Qualifier
annotation ThreadSafe {}

@Qualifier
annotation Production {}

@Component
@ThreadSafe
@Production
class SomeComponent {}</programlisting>
<simpara>Qualifiers may have attributes of any supported type:</simpara>
<itemizedlist>
<listitem>
<simpara>primitive value</simpara>
</listitem>
<listitem>
<simpara>String</simpara>
</listitem>
<listitem>
<simpara>enum</simpara>
</listitem>
<listitem>
<simpara>class literal</simpara>
</listitem>
<listitem>
<simpara>annotation (any annotation is supported, even annotations not marked with <literal>@Qualifier</literal>)</simpara>
</listitem>
<listitem>
<simpara>array of any of the above types</simpara>
</listitem>
</itemizedlist>
<simpara>Example:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Qualifier
annotation Language {
  String value
}

@Component
@Language("english")
class SomeComponent {}</programlisting>
</section>
<section xml:id="component-typesignature">
<title>Type signature of components</title>
<simpara>Every component has a <emphasis>type signature</emphasis> <literal>(cT, cQ)</literal> that is composed of</simpara>
<itemizedlist>
<listitem>
<simpara><literal>cT</literal>: a Java type and</simpara>
</listitem>
<listitem>
<simpara><literal>cQ</literal>: a set of qualifiers.</simpara>
</listitem>
</itemizedlist>
<simpara>In case of a <emphasis>component class</emphasis> these are defined as</simpara>
<itemizedlist>
<listitem>
<simpara><literal>cT</literal>: if specified explicitly then <literal>@Component.type</literal> otherwise the Java type of the component class declaration and</simpara>
</listitem>
<listitem>
<simpara><literal>cQ</literal>: the set of qualifiers the component class is annotated with.</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="component-reference">Components can be referenced by a <emphasis>component reference</emphasis> <literal>rT, rQ</literal> where</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rT</literal>: a Java type</simpara>
</listitem>
<listitem>
<simpara><literal>rQ</literal>: a set of qualifiers</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="component-reference-resolution">A component with <literal>(cT, cQ)</literal> type signature satisfies a component reference <literal>(rT, rQ)</literal> if</simpara>
<itemizedlist>
<listitem>
<simpara><literal>cT</literal> is assignable to <literal>rT</literal> (using the typing rules of the Java language) and</simpara>
</listitem>
<listitem>
<simpara>the set <literal>cQ</literal> contains all elements of set <literal>rQ</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The operation of finding all components in a module satisfying a given component reference is called <emphasis>component reference resolution</emphasis>.<?asciidoc-br?>
<emphasis>Component reference resolution</emphasis> may result in zero or more components.</simpara>
<simpara>The most common <emphasis>component reference</emphasis> is the <emphasis>injection point</emphasis>: a <emphasis>component reference</emphasis> defined by an Xtend field, method or parameter declaration.</simpara>
</section>
<section xml:id="dependency-injection">
<title>@Inject / dependency injection</title>
<simpara>The most important feature of <emphasis>xtend-ioc</emphasis> is dependency injection i.e. the process of resolving a <emphasis>component</emphasis>'s references to other <emphasis>component</emphasis>s.<?asciidoc-br?>
In practice this means the <link linkend="component-reference-resolution">resolution</link> of <emphasis>injection point</emphasis>s.</simpara>
<simpara>There are two types of <emphasis>injection point</emphasis>s in <emphasis>component</emphasis>s:</simpara>
<itemizedlist>
<listitem>
<simpara>Field: the <emphasis>component reference</emphasis> is defined by a field declaration of the <emphasis>component class</emphasis></simpara>
</listitem>
<listitem>
<simpara>Constructor: the <emphasis>component reference</emphasis>s are defined by the parameter declarations of a <emphasis>component constructor</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>Different types of <emphasis>injection point</emphasis>s canbe mixed in the same <emphasis>component</emphasis>.</simpara>
<simpara>In case of <emphasis>optional</emphasis> dependencies the <emphasis>injection point</emphasis> should be annotated with <literal>@NotRequired</literal>. If the <emphasis>component reference</emphasis> cannot be resolved then <literal>null</literal> is injected.</simpara>
<tip>
<simpara>To ensure null-safety it is recommended to use <link linkend="indirect-component-references">indirect component references</link> instead of directly injected <emphasis>component instance</emphasis>s.</simpara>
</tip>
<tip>
<simpara>In this documentation <literal>@Inject</literal> refers to <literal>@com.erinors.ioc.shared.api.Inject</literal>.<?asciidoc-br?>
But <literal>@javax.inject.Inject</literal> is supported as well and their behaviour is currently identical.</simpara>
</tip>
<section xml:id="_field_injection">
<title>Field injection</title>
<simpara>Injected fields are marked with <literal>@Inject</literal>:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class SomeComponent {
  @Inject
  ReferenceToAnotherComponent anotherComponent
}</programlisting>
<simpara>Component reference resolution is performed using</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rT</literal> = type of the field declaration</simpara>
</listitem>
<listitem>
<simpara><literal>rQ</literal> = qualifiers the field is annotated with</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_constructor_injection">
<title>Constructor injection</title>
<simpara>Injected constructors are marked with <literal>@Inject</literal>:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class SomeComponent {
  @Inject
  new(AnotherComponent anotherComponent) {}
}</programlisting>
<simpara>Component reference resolution is performed for each constructor parameter with</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rT</literal> = type of the parameter declaration</simpara>
</listitem>
<listitem>
<simpara><literal>rQ</literal> = qualifiers the parameter is annotated with</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="indirect-component-references">
<title>Indirect component references</title>
<simpara>Indirect <emphasis>component reference</emphasis>s are useful if</simpara>
<itemizedlist>
<listitem>
<simpara>more than one instance of the <emphasis>component</emphasis> is required (this is useful for <link linkend="component-scope-prototype">prototype scoped components</link>)</simpara>
</listitem>
<listitem>
<simpara>instantiation of the referenced <emphasis>component</emphasis> should be delayed for some reason</simpara>
</listitem>
</itemizedlist>
<simpara>Indirect <emphasis>component reference</emphasis>s are supported by injecting a <emphasis>component supplier</emphasis>:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface Handler&lt;T&gt; {}

@Component
class AnotherComponent {
}

@Component
class TestComponent {
	@Inject <co xml:id="CO3-1"/>
	public Supplier&lt;AnotherComponent&gt; componentSupplier

	@Inject
	public AnotherComponent injectedComponent
}

@Module(components=#[AnotherComponent, TestComponent])
interface TestModule {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test()	{
		val module = TestModule.Peer.initialize
		val testComponent = module.testComponent
		assertTrue( <co xml:id="CO3-2"/>
			testComponent.injectedComponent == testComponent.componentSupplier.get
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>Inject supplier.</para>
</callout>
<callout arearefs="CO3-2">
<para>The directly injected and the indirectly supplied component instances are the same because <literal>AnotherComponent</literal> is <link linkend="component-scope-singleton">singleton</link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Currently only <literal>com.google.common.base.Supplier</literal> is supported as <emphasis>component supplier</emphasis> but there are plans to support others (eg. <literal>java.util.function.Supplier</literal>).</simpara>
</note>
<tip>
<simpara>Indirect <emphasis>component reference</emphasis>s are supported by annotating the <emphasis>injection point</emphasis> with <literal>@NotRequired</literal>. In this case the supplier returns <literal>null</literal>.</simpara>
</tip>
</section>
<section xml:id="_references_to_multiple_components">
<title>References to multiple components</title>
<simpara>When a <link linkend="component-reference">component reference</link> is <link linkend="component-reference-resolution">resolved</link> to multiple <emphasis>component</emphasis>s they can be injected as type <literal>List</literal> or <literal>Iterable</literal>:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface Handler {
}

@Component
class IntegerHandler implements Handler {
}

@Component
class DoubleHandler implements Handler {
}

@Component
class TestComponent {
	@Inject
	public List&lt;? extends Handler&gt; handlers <co xml:id="CO4-1"/>
	@Inject
	public Iterable&lt;Handler&gt; handlers2 <co xml:id="CO4-2"/>
}

@Module(components=#[IntegerHandler, DoubleHandler, TestComponent])
interface TestModule {
	def IntegerHandler integerHandler()

	def DoubleHandler doubleHandler()

	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		assertEquals(
			#{module.doubleHandler, module.integerHandler},
			module.testComponent.handlers.toSet
		)
		assertEquals(
			module.testComponent.handlers,
			module.testComponent.handlers2
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Inject list of <emphasis>component reference</emphasis>s by type <literal>List&lt;? extends Handler&gt;</literal>.</para>
</callout>
<callout arearefs="CO4-2">
<para>Inject list of <emphasis>component reference</emphasis>s by type <literal>Iterable&lt;Handler&gt;</literal>.</para>
</callout>
</calloutlist>
<tip>
<simpara>Of course the <emphasis>component reference</emphasis> can be injected as a <literal>List</literal> even if it is <emphasis>resolved</emphasis> to only one <emphasis>component instance</emphasis>.</simpara>
</tip>
<tip>
<simpara>If no <emphasis>component</emphasis>s are compatible with the <emphasis>component reference</emphasis> then an empty <literal>List</literal> would be injected.<?asciidoc-br?>
This is valid only if <emphasis>injection point</emphasis> is annotated with <literal>@Optional</literal> otherwise a compilation error is raised.</simpara>
</tip>
</section>
<section xml:id="_generic_component_references">
<title>Generic component references</title>
<simpara>Generic components can be referenced as expected:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface Handler&lt;T&gt; {
}

@Component
class IntegerHandler implements Handler&lt;Integer&gt; {
}

@Component
class DoubleHandler implements Handler&lt;Double&gt; {
}

@Component
class TestComponent {
	@Inject
	public Handler&lt;Integer&gt; integerHandler

	@Inject
	public List&lt;Handler&lt;? extends Number&gt;&gt; numberHandlers <co xml:id="CO5-1"/>
}

@Module(components=#[IntegerHandler, DoubleHandler, TestComponent])
interface TestModule {
	def IntegerHandler integerHandler()

	def DoubleHandler doubleHandler()

	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		assertTrue(module.integerHandler == module.testComponent.integerHandler)
		assertTrue(
			#{module.doubleHandler, module.integerHandler} == module.testComponent.numberHandlers.toSet
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Both <literal>List&lt;Handler&lt;? extends Number&gt;&gt;</literal> and <literal>List&lt;? extends Handler&lt;? extends Number&gt;&gt;</literal> are valid. <literal>Iterable</literal> could be used as well instead of <literal>List</literal>.<?asciidoc-br?>
But <literal>List&lt;Handler&lt;Number&gt;&gt;</literal> would not be valid because there is no component implementing <literal>Handler&lt;Number&gt;</literal> (note that because of Java typing rules, <literal>Handler&lt;Integer&gt;</literal> is not assignable to <literal>Handler&lt;Number&gt;</literal>, only to <literal>Handler&lt;? extends Number&gt;</literal>).</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="component-scope">
<title>@Scope / component scope</title>
<simpara>By default every component has only one instance. When the <emphasis>component</emphasis> is <link linkend="component-reference">referenced</link> multiple times the same instance is returned always.<?asciidoc-br?>
This behaviour is defined by the <emphasis>scope</emphasis> of the <emphasis>component</emphasis> which defines whether a new instance of the <emphasis>component</emphasis> should be created or an existing instance should be used when the <emphasis>component</emphasis> is referenced.<?asciidoc-br?>
The built-in scopes are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>singleton</emphasis> and</simpara>
</listitem>
<listitem>
<simpara><emphasis>prototype</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis>scope</emphasis> of a <emphasis>component</emphasis> can be specified by the <emphasis>scope annotation</emphasis>.<?asciidoc-br?>
If a <emphasis>component</emphasis> does not have an explicit <emphasis>scope annotation</emphasis> then its scope will be the default <link linkend="component-scope-singleton">singleton scope</link>.</simpara>
<note>
<simpara>Custom scopes can be added by implementing a <literal>ScopeManager</literal>.</simpara>
</note>
<section xml:id="component-scope-singleton">
<title>@Singleton / singleton scope</title>
<simpara><emphasis>Components</emphasis> with <emphasis>singleton scope</emphasis> have never more than one instance.<?asciidoc-br?>
Multiple references to the same <emphasis>component</emphasis> are <link linkend="component-reference-resolution">resolved</link> to the same component instance.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component <co xml:id="CO6-1"/>
class TestComponent {
}

@Module(components=TestComponent)
interface TestModule {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		val testComponent1 = module.testComponent
		val testComponent2 = module.testComponent
		assertTrue( <co xml:id="CO6-2"/>
			testComponent1 == testComponent2
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Define <emphasis>singleton</emphasis> <emphasis>component</emphasis>.</para>
</callout>
<callout arearefs="CO6-2">
<para>All references to the <emphasis>component</emphasis> returns the same <emphasis>component instance</emphasis>.</para>
</callout>
</calloutlist>
<simpara>This is the default <emphasis>scope</emphasis> so usually no <emphasis>scope annotation</emphasis> is specified on <emphasis>singleton</emphasis> components.<?asciidoc-br?>
(So although there there is a <emphasis>scope annotation</emphasis> <literal>@Singleton</literal>, it is rarely used.)</simpara>
</section>
<section xml:id="component-scope-prototype">
<title>@Prototype / prototype scope</title>
<simpara><emphasis>Components</emphasis> annotated with <literal>@Prototype</literal> have <emphasis>prototype scope</emphasis>.<?asciidoc-br?>
Each reference to a <emphasis>prototype</emphasis> scoped <emphasis>component</emphasis> <link linkend="component-reference-resolution">resolves</link> to a new instance of the <emphasis>component</emphasis>.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component
@Prototype <co xml:id="CO7-1"/>
class TestComponent {
}

@Module(components=TestComponent)
interface TestModule {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		val testComponent1 = module.testComponent
		val testComponent2 = module.testComponent
		assertTrue( <co xml:id="CO7-2"/>
			testComponent1 != testComponent2
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Define <emphasis>prototype</emphasis> <emphasis>component</emphasis>.</para>
</callout>
<callout arearefs="CO7-2">
<para>Each references to the <emphasis>component</emphasis> returns a new <emphasis>component instance</emphasis>.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="component-lifecycle-annotations">
<title>@PostConstruct and @PreDestroy / lifecycle callbacks</title>
<simpara>Methods in <emphasis>component class</emphasis>es are <emphasis>lifecycle callbacks</emphasis> if they are annotated with <emphasis>lifecycle annotations</emphasis>:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Lifecycle annotation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>@PostConstruct</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The method is called after the given <emphasis>component instance</emphasis> is created and its dependencies are injected.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>@PreDestroy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The method is called when the given <emphasis>component instance</emphasis> is in the process of being disposed.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>The <literal>@PreDestroy</literal> <emphasis>lifecycle annotation</emphasis> is not supported by all <emphasis>scope</emphasis>s.<?asciidoc-br?>
For example the <emphasis>singleton scope</emphasis> supports it but the <emphasis>prototype scope</emphasis> does not.</simpara>
</note>
<note>
<simpara><literal>@PreDestroy</literal> methods are called by the <emphasis>scope manager</emphasis> before the <emphasis>component instance</emphasis> is being disposed.<?asciidoc-br?>
In case of <emphasis>singleton</emphasis> <emphasis>components</emphasis> this happens only when their <emphasis>module</emphasis> is <link linkend="module-close">closed</link>.</simpara>
</note>
<simpara>Example:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component <co xml:id="CO8-1"/>
class TestComponent {
	@Accessors(PUBLIC_GETTER)
	static String status = "uninitialized" <co xml:id="CO8-2"/>

	@PostConstruct <co xml:id="CO8-3"/>
	def void initialize() {
		status = "initialized"
	}

	@PreDestroy <co xml:id="CO8-4"/>
	def void close() {
		status = "closed"
	}
}

@Module(components=TestComponent)
interface TestModule {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize <co xml:id="CO8-5"/>
		assertEquals("uninitialized", TestComponent.status) <co xml:id="CO8-6"/>
		module.testComponent <co xml:id="CO8-7"/>
		assertEquals("initialized", TestComponent.status)
		module.close <co xml:id="CO8-8"/>
		assertEquals("closed", TestComponent.status)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Declare <literal>TestComponent</literal> of <emphasis>scope</emphasis> <emphasis>singleton</emphasis>.<?asciidoc-br?>
(Adding <literal>@Prototype</literal> to this class would result in a compile-time error because the <emphasis>prototype scope</emphasis> does not support <literal>@PreDestroy</literal> methods.)</para>
</callout>
<callout arearefs="CO8-2">
<para>Declare static status field (the unit test will use it).</para>
</callout>
<callout arearefs="CO8-3">
<para>Declare <literal>@PostConstruct</literal> callback method.</para>
</callout>
<callout arearefs="CO8-4">
<para>Declare <literal>@PreDestroy</literal> callback method.</para>
</callout>
<callout arearefs="CO8-5">
<para>Initialize module.</para>
</callout>
<callout arearefs="CO8-6">
<para>The <emphasis>component</emphasis> is not initialized yet (because it is not <link linkend="component-eager">eager</link>).</para>
</callout>
<callout arearefs="CO8-7">
<para>The <emphasis>component</emphasis> is intialized when first referenced (i.e. after the single instance of it is created), <literal>@PostConstruct</literal> callbacks are called in this phase.</para>
</callout>
<callout arearefs="CO8-8">
<para>The <emphasis>component</emphasis> is unintialized when the <emphasis>module</emphasis> is closed, <literal>@PreDestroy</literal> callbacks are called in this phase.</para>
</callout>
</calloutlist>
</section>
<section xml:id="component-eager">
<title>@Eager / eager components</title>
<simpara>By default <emphasis>component</emphasis>s are instantiated only when they are first referenced.<?asciidoc-br?>
To force the eager instantiation of a <emphasis>component</emphasis> it should be annotated with <literal>@Eager</literal>.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component <co xml:id="CO9-1"/>
class LazyComponent {
	@Accessors(PUBLIC_GETTER)
	static String status = "uninitialized"

	@PostConstruct
	def void initialize() {
		status = "initialized"
	}
}

@Component
@Eager <co xml:id="CO9-2"/>
class EagerComponent {
	@Accessors(PUBLIC_GETTER)
	static String status = "uninitialized"

	@PostConstruct
	def void initialize() {
		status = "initialized"
	}
}

@Module(components=#[LazyComponent, EagerComponent])
interface TestModule {
	def LazyComponent lazyComponent()

	def EagerComponent eagerComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		assertEquals( <co xml:id="CO9-3"/>
			"uninitialized",
			LazyComponent.status
		)
		assertEquals( <co xml:id="CO9-4"/>
			"initialized",
			EagerComponent.status
		)
		module.lazyComponent <co xml:id="CO9-5"/>
		assertEquals( <co xml:id="CO9-6"/>
			"initialized",
			LazyComponent.status
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para><emphasis>Component</emphasis>s are lazy by default.</para>
</callout>
<callout arearefs="CO9-2">
<para>Define <emphasis>eager</emphasis> component.</para>
</callout>
<callout arearefs="CO9-3">
<para>The <emphasis>lazy</emphasis> <emphasis>component</emphasis> is not instantiated when the <emphasis>module</emphasis> is created.</para>
</callout>
<callout arearefs="CO9-4">
<para>The <emphasis>eager</emphasis> <emphasis>component</emphasis> is instantiated right after the <emphasis>module</emphasis> is created.</para>
</callout>
<callout arearefs="CO9-5">
<para>Force instantiation of the <emphasis>lazy</emphasis> <emphasis>component</emphasis>.</para>
</callout>
<callout arearefs="CO9-6">
<para>The <emphasis>lazy</emphasis> <emphasis>component instance</emphasis> is now initialized.</para>
</callout>
</calloutlist>
<tip>
<simpara><literal>@Eager</literal> is usually used on <emphasis>singleton</emphasis> <emphasis>component</emphasis>s.</simpara>
</tip>
<tip>
<simpara>The intended initialization order of eager components can be specified by <literal>@Priority</literal>.</simpara>
</tip>
<note>
<simpara>If a <emphasis>prototype scope</emphasis>d <emphasis>component</emphasis> is marked as <literal>@Eager</literal> then right after the <emphasis>component instance</emphasis> is created, it is immediately dereferenced by the <emphasis>module instance</emphasis>.</simpara>
</note>
</section>
<section xml:id="component-providers">
<title>@Provider / components instantiated by user code</title>
<simpara>There are cases when we would like to use instances of a Java class as components but the class does not comply with the <link linkend="component-class-requirements">requirements of component classes</link>.<?asciidoc-br?>
In most cases it is possible to create a subclass with a valid component constructor but usually it is not practical.
Besides if the class is final - like <literal>String</literal> (yes, any Java object can be a component, even a string) - then there is no way to turn it into a component class.</simpara>
<simpara>To overcome these limitations, component classes can provide other component instances by <emphasis>provider method</emphasis>s.</simpara>
<note>
<simpara><emphasis>Provider method</emphasis>s must have an explicit return type, type inference is not supported.</simpara>
</note>
<section xml:id="_simple_component_providers">
<title>Simple component providers</title>
<simpara>Simple component providers are no-args instance methods defined in normal components and annotated with <literal>@Provider</literal>.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">class ProvidedComponent { <co xml:id="CO10-1"/>
}

@Component
class MainComponent {
  @Provider
  def ProvidedComponent provider() {
    new ProvidedComponent() <co xml:id="CO10-2"/>
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>The provided component&#8217;s class is not annotated with <literal>@Component</literal>, it&#8217;s a simple POJO.</para>
</callout>
<callout arearefs="CO10-2">
<para>Create a new instance of the provided component using the <literal>new</literal> operator.</para>
</callout>
</calloutlist>
<simpara>Altough in this case the <emphasis>provided</emphasis> component is instantiated directly using the <literal>new</literal> operator, its lifecycle is managed by the module, and similar rules apply to them as to normal components:</simpara>
<itemizedlist>
<listitem>
<simpara>they can have <link linkend="component-qualifiers">qualifiers</link> (declared on the <emphasis>provider method</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>they are <link linkend="component-scope-singleton">singleton</link> by default but can have a <link linkend="component-scope">custom scope</link> (declared on the <emphasis>provider method</emphasis>)</simpara>
</listitem>
</itemizedlist>
<simpara>There are important differences as well:</simpara>
<itemizedlist>
<listitem>
<simpara>A <emphasis>provided component</emphasis>'s <link linkend="component-typesignature">type signature</link> is composed of</simpara>
<itemizedlist>
<listitem>
<simpara>the return type of the <emphasis>provider method</emphasis> and</simpara>
</listitem>
<listitem>
<simpara>the qualifiers statically declared on the <emphasis>provider method</emphasis> and the parameterized qualifiers supported by the <emphasis>provider method</emphasis> (see <xref linkend="parameterized-component-providers"/>).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link linkend="component-lifecycle-annotations">lifecycle annotations</link> are not supported.</simpara>
</listitem>
<listitem>
<simpara>They usually don&#8217;t have <literal>@Inject</literal>-ed dependencies but use the injected dependencies of the enclosing component.<?asciidoc-br?>
(They may have injected dependencies like <link linkend="dependency-injection-for-non-components">any POJOs</link> but the resulting code is more readable if the dependecies are passed explicitly to the constructor of the implementing class.)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="parameterized-component-providers">
<title>Parameterized component providers</title>
<simpara>Parameterized component providers are very similar to <link linkend="component-providers">simple component providers</link>, the only difference is that they can provide <emphasis>component instance</emphasis>s for multiple <emphasis>qualifier</emphasis>s.</simpara>
<warning>
<simpara><emphasis>Parameterized component providers</emphasis> is an experimental feature, use it at your own risk.</simpara>
</warning>
<note>
<simpara>As all features of <emphasis>xtend-ioc</emphasis>, <emphasis>parameterized component providers</emphasis> is a compile-time feature.</simpara>
</note>
<programlisting language="xtend" linenumbering="unnumbered">@Qualifier <co xml:id="CO11-1"/>
annotation ConfigurationValue {
	String value
}

@Component
class ProviderComponent {
	Properties configuration

	@PostConstruct
	def void initialize() {
		// In a real provider the configuration would be loaded from a file
		configuration = new Properties
		configuration.setProperty("a", "A")
		configuration.setProperty("b", "B")
	}

	@Provider( <co xml:id="CO11-2"/>
	parameterizedQualifiers=@ParameterizedQualifier(qualifier=ConfigurationValue, <co xml:id="CO11-3"/>
	attributeName="value", <co xml:id="CO11-4"/>
	parameterName="configurationName" <co xml:id="CO11-5"/>
	))
	def String configurationValueProvider(String configurationName) {
		return configuration.getProperty(configurationName)
	}
}

@Component <co xml:id="CO11-6"/>
class TestComponent {
	@Inject
	@ConfigurationValue("a")
	public String a

	@Inject
	@ConfigurationValue("b")
	public String b
}

@Module(components=#[ProviderComponent, TestComponent])
interface TestModule {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		val testComponent = module.testComponent
		assertEquals("A", testComponent.a) <co xml:id="CO11-7"/>
		assertEquals("B", testComponent.b)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Declare qualifier annotation with attributes.</para>
</callout>
<callout arearefs="CO11-2">
<para>Declare parameterized provider.</para>
</callout>
<callout arearefs="CO11-3">
<para>Specify the qualifier annotation supported by the provider.</para>
</callout>
<callout arearefs="CO11-4">
<para>Specify the annotation attribute name.</para>
</callout>
<callout arearefs="CO11-5">
<para>Specify the method parameter name the annotation attribute value is mapped to.</para>
</callout>
<callout arearefs="CO11-6">
<para>Declare component with injected fields.</para>
</callout>
<callout arearefs="CO11-7">
<para>Test injected values.</para>
</callout>
</calloutlist>
</section>
</section>
</section>
<section xml:id="_modules">
<title>Modules</title>
<section xml:id="module-declaration">
<title>@Module / defining modules</title>
<simpara>A <emphasis>module</emphasis> is defined by a Java interface annotated with <literal>@Module</literal>.<?asciidoc-br?>
The <literal>@Module</literal> annotation defines the <emphasis>component class</emphasis>es managed by the module</simpara>
<itemizedlist>
<listitem>
<simpara>explicitly by listing the <emphasis>component class</emphasis>es using the <literal>components</literal> attribute and/or</simpara>
</listitem>
<listitem>
<simpara>implicitly by specifying the attribute <literal>componentScanClasses</literal> and/or <literal>componentImporters</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="component-importer">Component importers specify the <emphasis>component</emphasis>s to be imported by using <literal>@ImportComponents</literal>.</simpara>
<simpara xml:id="component-scan">Component scan attempts to find <emphasis>component</emphasis>s recursively in the package of each listed class.</simpara>
<simpara>Component scan example:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface SomeInterface {
}

@Component
class Component1 implements SomeInterface {
}

@Component
class Component2 implements SomeInterface {
}

@Module(componentScanClasses=TestModule) <co xml:id="CO12-1"/>
interface TestModule {
	def List&lt;SomeInterface&gt; instances()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		assertEquals(2, module.instances.size) <co xml:id="CO12-2"/>
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>Define component scan root packages.</para>
</callout>
<callout arearefs="CO12-2">
<para>Both <literal>Component1</literal> and <literal>Component2</literal> is found by component scanning.</para>
</callout>
</calloutlist>
<warning>
<simpara>Component scan is an experimental feature, use it at your own risk.</simpara>
</warning>
</section>
<section xml:id="_module_inheritance">
<title>Module inheritance</title>
<simpara>A <emphasis>module</emphasis> can inherit other <emphasis>module</emphasis>s by extending the their interface.<?asciidoc-br?>
When module <literal>M1</literal> inherits module <literal>M2</literal> then all components contained by <literal>M2</literal> will be managed by <literal>M1</literal> as well. This rule is recursive.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class TestComponent {
}

@Module(components=TestComponent)
interface ParentModule {
	def TestComponent testComponent()
}

@Module <co xml:id="CO13-1"/>
interface TestModule extends ParentModule {
}

class Example {
	@Test
	def void test() {
		assertNotNull( <co xml:id="CO13-2"/>
			TestModule.Peer.initialize.testComponent
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para><literal>TestModule</literal> inherits <literal>ParentModule</literal>.</para>
</callout>
<callout arearefs="CO13-2">
<para>The inherited <emphasis>component</emphasis> is available in <literal>TestModule</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="module-singleton">
<title>Module lifecycle / Singleton modules</title>
<simpara>A <emphasis>module</emphasis> must be instantiated before it can be used. Only <emphasis>non-abstract</emphasis> modules can be instantiated.<?asciidoc-br?></simpara>
<simpara>There are two types of modules specified by <literal>@Module.singleton</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Singleton: the <emphasis>module</emphasis> has exactly one instance.<?asciidoc-br?>
This singleton instance of the module <literal>ModuleInterface</literal> can be instantiated by calling <literal>ModuleInterface.Peer.initialize()</literal>.<?asciidoc-br?>
The singleton instance is available by calling <literal>ModuleInterface.Peer.get()</literal>.</simpara>
</listitem>
<listitem>
<simpara>Non-singleton: the module may have multiple instances, a new instance of the module <literal>ModuleInterface</literal> can be created by calling <literal>ModuleInterface.Peer.constructInstance()</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>In case of inheritance of singleton modules all modules in the inheritance chain share the same module instance:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class TestComponent {
}

@Module(components=TestComponent)
interface ParentModule {
	def TestComponent testComponent()
}

@Module <co xml:id="CO14-1"/>
interface TestModule extends ParentModule {
}

class Example {
	@Test
	def void test() {
		TestModule.Peer.initialize <co xml:id="CO14-2"/>
		assertTrue(TestModule.Peer.get === ParentModule.Peer.get) <co xml:id="CO14-3"/>
		assertTrue( <co xml:id="CO14-4"/>
			TestModule.Peer.get.testComponent ===
			ParentModule.Peer.get.testComponent
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para><literal>TestModule</literal> inherits <literal>ParentModule</literal>.</para>
</callout>
<callout arearefs="CO14-2">
<para>Initialize <literal>TestModule</literal>.</para>
</callout>
<callout arearefs="CO14-3">
<para>Both <literal>TestModule</literal> and <literal>ParentModule</literal> share the same runtime instance.</para>
</callout>
<callout arearefs="CO14-4">
<para><literal>TestComponent</literal> is available from both <emphasis>module</emphasis> instances.</para>
</callout>
</calloutlist>
<simpara xml:id="module-close">When the <emphasis>module instance</emphasis> is not needed anymore (e.g. on application shutdown) it should be closed by calling <literal>ModuleInterface.Peer.close()</literal>.<?asciidoc-br?>
During the close operation <link linkend="component-lifecycle-annotations">predestroy methods</link> are called on the corresponding <emphasis>component instance</emphasis>s.</simpara>
</section>
<section xml:id="module-abstract">
<title>Abstract and non-abstract modules</title>
<simpara>All <emphasis>module</emphasis> is <emphasis>non-abstract</emphasis> by default that is all <emphasis>component references</emphasis>s must be <link linkend="component-reference-resolution">resolvable</link>, otherwise a compilation error is raised.</simpara>
<simpara>If it is known that not all <emphasis>component references</emphasis>s are available (on purpose) then the <emphasis>module</emphasis> must be explicitly marked as <emphasis>abstract</emphasis> by specifying the <literal>@Module(isAbstract=true)</literal>.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface SomeService {
}

@Component
class TestComponent {
	@Inject
	public SomeService someService
}

@Module(components=TestComponent, isAbstract=true) <co xml:id="CO15-1"/>
interface ParentModule {
	def TestComponent testComponent()
}

@Component
class SomeServiceComponent implements SomeService {
}

@Module(components=SomeServiceComponent)
interface TestModule extends ParentModule {
	def SomeService someService()
}

class Example {
	@Test
	def void test() {
		// Compile-time error: ParentModule.Peer.initialize() <co xml:id="CO15-2"/>
		val module = TestModule.Peer.initialize
		assertTrue(TestModule.Peer.get === ParentModule.Peer.get) <co xml:id="CO15-3"/>
		assertTrue(module.testComponent.someService === module.someService) <co xml:id="CO15-4"/>
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para><literal>ParentModule</literal> is declared as <emphasis>abstract</emphasis> because the <literal>TestComponent.someService</literal> <emphasis>component reference</emphasis> is not resolvable.</para>
</callout>
<callout arearefs="CO15-2">
<para><literal>ParentModule</literal> is <emphasis>abstract</emphasis> therefore no <literal>initialize()</literal> method is available on it.</para>
</callout>
<callout arearefs="CO15-3">
<para>Both <literal>TestModule</literal> and <literal>ParentModule</literal> share the same runtime instance. There is no  difference compared to <emphasis>non-abstract</emphasis> <emphasis>module</emphasis>s.</para>
</callout>
<callout arearefs="CO15-4">
<para>Dependency injection works between <emphasis>module</emphasis>s as expected.</para>
</callout>
</calloutlist>
</section>
<section xml:id="module-level-component-references">
<title>Module-level component references</title>
<simpara><emphasis>Module</emphasis> interfaces may declare <link linkend="component-reference">component references</link>:</simpara>
<itemizedlist>
<listitem>
<simpara>rT: the return type of the method declaration</simpara>
</listitem>
<listitem>
<simpara>rQ: the qualifiers the method declaration is annotated with</simpara>
</listitem>
</itemizedlist>
<simpara>These methods can be called on the <emphasis>module</emphasis> instance from "external" code:</simpara>
<programlisting language="xtend" linenumbering="unnumbered">interface SomeInterface {
}

@Component
class TestComponent implements SomeInterface {
}

@Module(components=TestComponent)
interface TestModule { <co xml:id="CO16-1"/>
	def TestComponent testComponent()

	def SomeInterface someInterface()

	def Supplier&lt;SomeInterface&gt; someInterfaceSupplier()
}

class Example {
	@Test
	def void test() { <co xml:id="CO16-2"/>
		val module = TestModule.Peer.initialize
		assertTrue(module.testComponent === module.someInterface)
		assertTrue(module.testComponent === module.someInterfaceSupplier.get)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Declare <emphasis>module</emphasis> with module-level <emphasis>component reference</emphasis>s.</para>
</callout>
<callout arearefs="CO16-2">
<para>All declared <emphasis>component reference</emphasis>s refer to the same <emphasis>singleton</emphasis> <literal>TestComponent</literal> instance.</para>
</callout>
</calloutlist>
</section>
<section xml:id="_the_relation_of_modules_and_component_classes">
<title>The relation of modules and component classes</title>
<simpara>The same <emphasis>component class</emphasis> can be contained by multiple <emphasis>module</emphasis>s.<?asciidoc-br?>
In this case component dependency resolutions happens independently in each module, so it is possible that a <emphasis>component reference</emphasis> is resolved to different <emphasis>component instance</emphasis>s.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Component <co xml:id="CO17-1"/>
class TestComponent {
	@Inject
	public String value
}

@Component
class Provider1 {
	@Provider <co xml:id="CO17-2"/>
	def String provider() '''1'''
}

@Component
class Provider2 {
	@Provider <co xml:id="CO17-3"/>
	def String provider() '''2'''
}

@Module(components=#[TestComponent, Provider1]) <co xml:id="CO17-4"/>
interface TestModule1 {
	def TestComponent testComponent()
}

@Module(components=#[TestComponent, Provider2]) <co xml:id="CO17-5"/>
interface TestModule2 {
	def TestComponent testComponent()
}

class Example {
	@Test
	def void test() {
		val module1 = TestModule1.Peer.initialize
		val module2 = TestModule2.Peer.initialize
		val testComponent1 = module1.testComponent
		val testComponent2 = module2.testComponent
		assertEquals( <co xml:id="CO17-6"/>
			"1", testComponent1.value
		)
		assertEquals( <co xml:id="CO17-7"/>
			"2", testComponent2.value
		)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>Declare <emphasis>component</emphasis> <literal>TestComponent</literal> with injected dependency.</para>
</callout>
<callout arearefs="CO17-2">
<para>Declare <emphasis>component provider</emphasis> <literal>Provider1</literal> with value <literal>"1"</literal>.</para>
</callout>
<callout arearefs="CO17-3">
<para>Declare <emphasis>component provider</emphasis> <literal>Provider2</literal> with value <literal>"2"</literal>.</para>
</callout>
<callout arearefs="CO17-4">
<para><literal>TestModule1</literal> contains <literal>TestComponent</literal> and <literal>Provider1</literal>.</para>
</callout>
<callout arearefs="CO17-5">
<para><literal>TestModule2</literal> contains <literal>TestComponent</literal> and <literal>Provider2</literal>.</para>
</callout>
<callout arearefs="CO17-6">
<para><literal>TestComponent&#8217;s dependency is resolved using `Provider1</literal> in <literal>TestModule1</literal>.</para>
</callout>
<callout arearefs="CO17-7">
<para><literal>TestComponent&#8217;s dependency is resolved using `Provider2</literal> in <literal>TestModule2</literal>.</para>
</callout>
</calloutlist>
<warning>
<simpara>Because each <emphasis>module</emphasis> may have only one instance, inheritance is not supported with a common parent <emphasis>module</emphasis>.<?asciidoc-br?>
I.e. if both <literal>TestModule1</literal> and <literal>TestModule2</literal> would inherit from the same parent <emphasis>module</emphasis>, only <literal>module1</literal> could be initialized, the initialization of <literal>module2</literal> would fail.</simpara>
</warning>
</section>
<section xml:id="component-dependency-graph">
<title>The component dependency graph</title>
<simpara>Each non-abstract <emphasis>module</emphasis> defines a <emphasis>dependency graph</emphasis> between <emphasis>component</emphasis>s: it is a <link xlink:href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph (DAG)</link> where each node <literal>Cn</literal> is a <emphasis>component</emphasis> and each directed edge <literal>C1</literal>&#8594;`C2` corresponds to a direct <emphasis>component reference</emphasis> declared in <literal>C1</literal> and <link linkend="component-reference-resolution">resolved</link> as <literal>C2</literal>.
Note that indirect component references (by <literal>Supplier</literal> or <literal>Optional</literal>) are not present in the <emphasis>dependency graph</emphasis>.</simpara>
<simpara>If the <emphasis>dependency graph</emphasis> would not be a DAG i.e. it contains a <link xlink:href="https://en.wikipedia.org/wiki/Cycle_graph#Directed_cycle_graph">directed cycle</link> then a compile-time error is raised.</simpara>
<simpara>The following example does not compile, there are two compile-time errors:</simpara>
<itemizedlist>
<listitem>
<simpara>Error message #1:
Component reference cycle detected: Component1 &#8594; Component4 &#8594; Component3 &#8594; Component1 [E004]</simpara>
</listitem>
<listitem>
<simpara>Error message #2:
Component reference cycle detected: Component1 &#8594; Component4 &#8594; Component3 &#8594; Component2 &#8594; Component1 [E004]</simpara>
</listitem>
</itemizedlist>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class Component1 {
	@Inject <co xml:id="CO18-1"/>
	Component4 component4

	def boolean someBusinessMethod() {
		component4.anotherBusinessMethod
	}
}

@Component
class Component2 {
	@Inject
	public Component1 component1
}

@Component
class Component3 {
	@Inject
	public Component1 component1

	@Inject
	public Component2 component2
}

@Component
class Component4 {
	@Inject
	public Component3 component3

	def anotherBusinessMethod() {
		true
	}
}

@Module(components=#[Component1, Component2, Component3, Component4])
interface TestModule
{
	def Component1 component1()
}</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Injecting <literal>Component4</literal> directly causes compile-time errors.</para>
</callout>
</calloutlist>
<simpara>The cycle can be avoided by referencing one of the affected components indirectly using a <literal>Supplier</literal>:</simpara>
<programlisting xml:id="component-dependency-graph-example-cycle-avoided" language="xtend" linenumbering="unnumbered">@Component
class Component1 {
	// Direct injection is not allowed because it would cause two cycles in the dependency graph.
	// @Inject
	// Component4 component4

	@Inject <co xml:id="CO19-1"/>
	Supplier&lt;Component4&gt; component4Supplier

	def boolean someBusinessMethod() {
		!component4Supplier.get.anotherBusinessMethod <co xml:id="CO19-2"/>
	}
}

@Component
class Component2 {
	@Inject
	public Component1 component1
}

@Component
class Component3 {
	@Inject
	public Component1 component1

	@Inject
	public Component2 component2
}

@Component
class Component4 {
	@Inject
	public Component3 component3

	def anotherBusinessMethod() {
		true
	}
}

@Module(components=#[Component1, Component2, Component3, Component4])
interface TestModule
{
	def Component1 component1()
}

class AvoidDependencyGraphCycleTest {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize
		assertFalse(module.component1.someBusinessMethod)
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Injection is done indirectly by <literal>Supplier&lt;Component4&gt;</literal>.</para>
</callout>
<callout arearefs="CO19-2">
<para>The component instance is referenced indirectly using <literal>Supplier.get()</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara><link linkend="component-providers">Component providers</link> reference their enclosing component directly.</simpara>
</note>
</section>
<section xml:id="_module_report">
<title>Module report</title>
<simpara>If the <emphasis>module</emphasis> <literal>ModuleName</literal> is compiled without errors, two additional files are generated next to the module interface declaration:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ModuleName.dot</literal>: the <emphasis>dependency graph</emphasis> in GraphViz format</simpara>
</listitem>
<listitem>
<simpara><literal>ModuleName.html</literal>: a HTML report that contains some information about the <emphasis>module</emphasis> like module properties, declared <emphasis>component</emphasis>s, the <emphasis>dependency graph</emphasis>, etc.</simpara>
</listitem>
</itemizedlist>
<simpara>E.g. the <link linkend="component-dependency-graph-example-cycle-avoided">example above</link> has the following graph:</simpara>
<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" viewBox="0.00 0.00 209.20 260.00" height="260pt" width="209pt">
<g transform="scale(1 1) rotate(0) translate(4 256)" class="graph" id="graph0">
<title>G</title>
<polygon points="-4,4 -4,-256 205.205,-256 205.205,4 -4,4" stroke="none" fill="white"></polygon>
<!-- 1 -->
<g class="node" id="node1"><title>1</title>
<ellipse ry="18" rx="74.7049" cy="-18" cx="74.6024" stroke="black" fill="none"></ellipse>
<text font-size="14.00" font-family="Times,serif" y="-13.8" x="74.6024" text-anchor="middle">Component1 [1]</text>
</g>
<!-- 2 -->
<g class="node" id="node2"><title>2</title>
<ellipse ry="18" rx="74.7049" cy="-90" cx="126.602" stroke="black" fill="none"></ellipse>
<text font-size="14.00" font-family="Times,serif" y="-85.8" x="126.602" text-anchor="middle">Component2 [2]</text>
</g>
<!-- 2&#45;&gt;1 -->
<g class="edge" id="edge1"><title>2-&gt;1</title>
<path d="M114.015,-72.055C107.755,-63.6287 100.067,-53.2798 93.1488,-43.9663" stroke="black" fill="none"></path>
<polygon points="95.8471,-41.7293 87.0742,-35.789 90.2279,-45.9036 95.8471,-41.7293" stroke="black" fill="black"></polygon>
</g>
<!-- 3 -->
<g class="node" id="node3"><title>3</title>
<ellipse ry="18" rx="74.7049" cy="-162" cx="74.6024" stroke="black" fill="none"></ellipse>
<text font-size="14.00" font-family="Times,serif" y="-157.8" x="74.6024" text-anchor="middle">Component3 [3]</text>
</g>
<!-- 3&#45;&gt;1 -->
<g class="edge" id="edge2"><title>3-&gt;1</title>
<path d="M61.0381,-143.972C54.0443,-134.09 46.2356,-121.047 42.6024,-108 38.3101,-92.5865 38.3101,-87.4135 42.6024,-72 45.2705,-62.4189 50.1905,-52.8397 55.3859,-44.5128" stroke="black" fill="none"></path>
<polygon points="58.407,-46.2908 61.0381,-36.0279 52.5812,-42.41 58.407,-46.2908" stroke="black" fill="black"></polygon>
</g>
<!-- 3&#45;&gt;2 -->
<g class="edge" id="edge3"><title>3-&gt;2</title>
<path d="M87.1901,-144.055C93.4496,-135.629 101.137,-125.28 108.056,-115.966" stroke="black" fill="none"></path>
<polygon points="110.977,-117.904 114.131,-107.789 105.358,-113.729 110.977,-117.904" stroke="black" fill="black"></polygon>
</g>
<!-- 4 -->
<g class="node" id="node4"><title>4</title>
<ellipse ry="18" rx="74.7049" cy="-234" cx="74.6024" stroke="black" fill="none"></ellipse>
<text font-size="14.00" font-family="Times,serif" y="-229.8" x="74.6024" text-anchor="middle">Component4 [4]</text>
</g>
<!-- 4&#45;&gt;3 -->
<g class="edge" id="edge4"><title>4-&gt;3</title>
<path d="M74.6024,-215.697C74.6024,-207.983 74.6024,-198.712 74.6024,-190.112" stroke="black" fill="none"></path>
<polygon points="78.1025,-190.104 74.6024,-180.104 71.1025,-190.104 78.1025,-190.104" stroke="black" fill="black"></polygon>
</g>
</g>
</svg>
<note>
<simpara>The module report is a work in progress.<?asciidoc-br?>
Currently graph rendering is very slow (done with <link xlink:href="https://github.com/mdaines/viz.js/">viz.js</link>).</simpara>
</note>
</section>
<section xml:id="_gwt_support">
<title>GWT support</title>
<simpara>If the <emphasis>module</emphasis> <literal>ModuleInterface</literal> is annotated with <literal>@GwtEntryPoint</literal> then a special class named <literal>ModuleInterfaceEntryPoint</literal> is generated.<?asciidoc-br?>
This class implements <literal>com.google.gwt.core.client.EntryPoint</literal> and the implementation instantiates the module.<?asciidoc-br?>
<emphasis>Component</emphasis>s with post-construct methods may be used to implement bootstrap code like UI construction.</simpara>
</section>
</section>
<section xml:id="_module_local_event_dispatching">
<title>Module-local event dispatching</title>
<simpara>Events allow simple communication between <emphasis>component instance</emphasis>s in a <emphasis>module</emphasis> instance:</simpara>
<simpara>Event classes are simple POJOs.</simpara>
<simpara>Events can be fired by invoking the <literal>fire()</literal> method of a special built-in component type <literal>Event&lt;EventClass&gt;</literal> that can be injected as usual.</simpara>
<simpara>Events can be observed by declaring instance methods in <emphasis>component</emphasis>s annotated with <literal>@EventObserver</literal>.<?asciidoc-br?>
The observed event type can be specified implicitly by a method parameter or explicitly by <literal>@EventObserver.type</literal> (in the latter case the event object is not available in the method).</simpara>
<simpara>An observer method receives all subtypes of its declared event type by default.
This can be changed by specifying the annotation attribute <literal>rejectSubtypes=true</literal>.</simpara>
<programlisting language="xtend" linenumbering="unnumbered">@Data <co xml:id="CO20-1"/>
class MessageEvent {
	String message
}

@Component
@Eager
@Priority(1) <co xml:id="CO20-2"/>
class EventSourceComponent {
	@Inject
	Event&lt;MessageEvent&gt; event <co xml:id="CO20-3"/>

	@PostConstruct
	def void componentInitialized() {
		fireEvent("C") <co xml:id="CO20-4"/>
	}

	@EventObserver(eventType=ModuleInitializedEvent) <co xml:id="CO20-5"/>
	def void moduleInitialize() {
		fireEvent("M") <co xml:id="CO20-6"/>
	}

	def void fireEvent(String message) {
		event.fire(new MessageEvent(message)) <co xml:id="CO20-7"/>
	}
}

@Component
@Eager
@Priority(0) <co xml:id="CO20-8"/>
class EventObserverComponent {
	val messages = newArrayList

	def getMessages() {
		messages.join(",")
	}

	@EventObserver <co xml:id="CO20-9"/>
	def void observe(MessageEvent event) {
		messages += event.message
	}
}

@Module(components=#[EventSourceComponent, EventObserverComponent])
interface TestModule {
	def EventSourceComponent source()

	def EventObserverComponent observer()
}

class Example {
	@Test
	def void test() {
		val module = TestModule.Peer.initialize <co xml:id="CO20-10"/>
		assertEquals("M", module.observer.messages) <co xml:id="CO20-11"/>
		module.source.fireEvent("1") <co xml:id="CO20-12"/>
		assertEquals("M,1", module.observer.messages) <co xml:id="CO20-13"/>
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Declare event class.</para>
</callout>
<callout arearefs="CO20-2">
<para><literal>EventSourceComponent</literal> is eagerly initialized before <literal>EventObserverComponent</literal>.</para>
</callout>
<callout arearefs="CO20-3">
<para>Inject event.</para>
</callout>
<callout arearefs="CO20-4">
<para>Fire event <literal>"C"</literal> when the <emphasis>component instance</emphasis> is initialized.</para>
</callout>
<callout arearefs="CO20-5">
<para>Declare event observer method without parameters.</para>
</callout>
<callout arearefs="CO20-6">
<para>Fire event <literal>"M"</literal> when the <emphasis>module instance</emphasis> is initialized.</para>
</callout>
<callout arearefs="CO20-7">
<para><literal>Event.fire()</literal> can be used to fire <emphasis>event</emphasis>s.</para>
</callout>
<callout arearefs="CO20-8">
<para><literal>EventObserverComponent</literal> is eagerly initialized after <literal>EventSourceComponent</literal>.</para>
</callout>
<callout arearefs="CO20-9">
<para>Declare event observer method receiving the <emphasis>event object</emphasis>.</para>
</callout>
<callout arearefs="CO20-10">
<para><literal>EventSourceComponent</literal> fires event <literal>"C"</literal> during component initialization and <literal>"M"</literal> during module initialization.</para>
</callout>
<callout arearefs="CO20-11">
<para><literal>EventObserverComponent</literal> received only <literal>"M"</literal> because it was initialized only after <literal>EventSourceComponent</literal>.</para>
</callout>
<callout arearefs="CO20-12">
<para>Fire event <literal>"1"</literal>.</para>
</callout>
<callout arearefs="CO20-13">
<para><literal>EventObserverComponent</literal> received message <literal>"1"</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="dependency-injection-for-non-components">
<title>Dependency injection for non-components</title>
<simpara>Dependency injection is supported for simple POJOs annotated with <literal>@Injectable</literal>. The <emphasis>module</emphasis> specified in this annotation will be used for <link linkend="component-reference-resolution">component reference resolution</link>.<?asciidoc-br?>
Both field and constructor injection is supported. Besides, the injection of individual constructor parameters is supported as well, see the example below.</simpara>
<simpara>Component reference resolution works differently for abstract and non-abstract modules:</simpara>
<itemizedlist>
<listitem>
<simpara>For non-abstract modules it works the same as in case of normal components.</simpara>
</listitem>
<listitem>
<simpara>However resolution is limited for abstract modules: a <emphasis>component reference</emphasis> can be resolved only if there is a compatible <link linkend="module-level-component-references">module-level component reference</link> declared.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Event dispatch is not supported for non-components.</simpara>
</warning>
<programlisting language="xtend" linenumbering="unnumbered">@Component
class ValueProvider {
	@Provider
	def String value() '''a'''
}

@Module(components=ValueProvider)
interface TestModule { <co xml:id="CO21-1"/>
	def String value()
}

@Injectable(TestModule) <co xml:id="CO21-2"/>
class Injectable1 {
	@Inject
	public String value
}

@Data
@Injectable(TestModule) <co xml:id="CO21-3"/>
class Injectable2 {
	String value

	@Inject
	new(String value) {
		this.value = value
	}
}

@Data
@Injectable(TestModule) <co xml:id="CO21-4"/>
class Injectable3 {
	int number

	String value

	new(int number, @Inject String value) {
		this.number = number
		this.value = value
	}
}

class Example {
	@Test
	def void test() {
		TestModule.Peer.initialize <co xml:id="CO21-5"/>
		assertEquals("a", new Injectable1().value) <co xml:id="CO21-6"/>
		assertEquals("a", new Injectable2().value) <co xml:id="CO21-7"/>
		assertEquals("a", new Injectable3(1).value) <co xml:id="CO21-8"/>
	}
}</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Declare module with provider component.</para>
</callout>
<callout arearefs="CO21-2">
<para>Declare injectable class <literal>Injectable1</literal> with field injection.</para>
</callout>
<callout arearefs="CO21-3">
<para>Declare injectable class <literal>Injectable2</literal> with constructor injection.</para>
</callout>
<callout arearefs="CO21-4">
<para>Declare injectable class <literal>Injectable3</literal> with constructor parameter injection.</para>
</callout>
<callout arearefs="CO21-5">
<para>Explicit module initialization is required before the <literal>@Injectable</literal> class is instantiated.</para>
</callout>
<callout arearefs="CO21-6">
<para>Instantiate <literal>Injectable1</literal>.</para>
</callout>
<callout arearefs="CO21-7">
<para>Instantiate <literal>Injectable2</literal>. Note that because the constructor is injected therefore the object is created using a generated no-args constructor.</para>
</callout>
<callout arearefs="CO21-8">
<para>Instantiate <literal>Injectable3</literal>. Note that because the declared 2-args constructor is injected therefore the object is created using a generated 1-arg constructor.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="_faq">
<title>FAQ</title>
<qandaset>
<qandaentry>
<question>
<simpara>What is the license for <emphasis>xtend-ioc</emphasis>?</simpara>
</question>
<answer>
<simpara>All sources code is licensed under <link xlink:href="https://www.mozilla.org/en-US/MPL/2.0/">MPL v2</link>.<?asciidoc-br?>
All documentation is licensed under <inlinemediaobject>
<imageobject>
<imagedata fileref="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"/>
</imageobject>
<textobject><phrase>80x15</phrase></textobject>
</inlinemediaobject></simpara>
</answer>
</qandaentry>
<qandaentry>
<question>
<simpara>Is Java supported?</simpara>
</question>
<answer>
<simpara>No, only Xtend is supported.<?asciidoc-br?>
Altough it would be possible to implement most <emphasis>xtend-ioc</emphasis> features using <link xlink:href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/package-summary.html">Java Annotation Processing</link>, it is not planned currently.</simpara>
</answer>
</qandaentry>
<qandaentry>
<question>
<simpara>Is Google Web Toolkit supported?</simpara>
</question>
<answer>
<simpara>Yes, the generated code is <link xlink:href="http://gwtproject.org/">GWT</link> compatible.</simpara>
</answer>
</qandaentry>
</qandaset>
</section>
<section xml:id="_appendix">
<title>Appendix</title>
<section xml:id="_message_codes">
<title>Message codes</title>
<variablelist>
<varlistentry>
<term>[E001] @Module is supported only for interface declarations.</term>
<listitem>
<simpara>Only interfaces may be annotated with <literal>@Module</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>[E002] @Component is supported only for class declarations.</term>
<listitem>
<simpara>Only classes may be annotated with <literal>@Component</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>[E003] @Injectable is supported only for class declarations.</term>
<listitem>
<simpara>Only classes may be annotated with <literal>@Injectable</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>[E004] Component reference cycle detected: ComponentX &#8594; &#8230;&#8203; &#8594; ComponentX</term>
<listitem>
<simpara>There is a cycle in the component dependency graph therefore the correct order of component instantiation cannot be resolved.
See the section about the <link linkend="component-dependency-graph">component dependency graph</link> how this error could be avoided.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>[E005] Component class should be non-generic: CLASS</term>
<listitem>
<simpara>Only component classes with not type parameters may be referenced by modules.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
</article>